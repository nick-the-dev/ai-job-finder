generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Job {
  id             String   @id @default(uuid())
  contentHash    String   @unique @map("content_hash")

  // Basic info
  title          String
  company        String
  description    String

  // Location
  location       String?
  isRemote       Boolean  @default(false) @map("is_remote")

  // Salary
  salaryMin      Int?     @map("salary_min")
  salaryMax      Int?     @map("salary_max")
  salaryCurrency String?  @map("salary_currency")

  // Source
  source         String   // serpapi, jobspy
  sourceId       String?  @map("source_id")
  applicationUrl String?  @map("application_url")

  // Timestamps
  postedDate     DateTime? @map("posted_date")
  firstSeenAt    DateTime  @default(now()) @map("first_seen_at")
  lastSeenAt     DateTime  @default(now()) @map("last_seen_at")

  // Relations
  matches        JobMatch[]

  @@map("jobs")
}

model JobMatch {
  id          String   @id @default(uuid())

  // Job relation
  jobId       String   @map("job_id")
  job         Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  // Resume fingerprint for caching (hash of resume text)
  resumeHash  String?  @map("resume_hash")

  // Match analysis
  score       Int      // 1-100
  reasoning   String   // Why this score

  // Skills analysis
  matchedSkills  String[] @map("matched_skills")
  missingSkills  String[] @map("missing_skills")

  // Recommendations
  pros        String[]
  cons        String[]

  // Timestamps
  createdAt   DateTime @default(now()) @map("created_at")

  // Telegram notifications
  sentNotifications SentNotification[]

  @@map("job_matches")
}

model SearchConfig {
  id              String   @id @default(uuid())
  name            String   @unique

  // Search criteria
  jobTitles       String[] @map("job_titles")
  locations       String[]
  isRemote        Boolean  @default(true) @map("is_remote")

  // Exclusions
  excludedTitles  String[] @map("excluded_titles")
  excludedCompanies String[] @map("excluded_companies")

  // Resume for matching
  resumeText      String?  @map("resume_text")

  // Notes
  notes           String?

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@map("search_configs")
}

// Cache for API query results to avoid duplicate calls
model QueryCache {
  id           String   @id @default(uuid())

  // Query parameters (hashed for lookup)
  queryHash    String   @unique @map("query_hash")

  // Query details
  query        String   // The search query
  location     String?
  isRemote     Boolean  @default(false) @map("is_remote")
  source       String   // serpapi, jobspy

  // Results metadata
  jobCount     Int      @map("job_count")

  // Timestamps
  fetchedAt    DateTime @default(now()) @map("fetched_at")
  expiresAt    DateTime @map("expires_at")

  @@map("query_cache")
}

// Cache for query expansions to avoid repeated LLM calls
model QueryExpansion {
  id              String   @id @default(uuid())

  // Cache key (hash of job titles + resume snippet)
  cacheKey        String   @unique @map("cache_key")

  // Original input
  originalQueries String[] @map("original_queries")

  // LLM-generated expansions
  expandedQueries String[] @map("expanded_queries")
  resumeSuggested String[] @map("resume_suggested")

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")

  @@map("query_expansions")
}

// Telegram bot user
model TelegramUser {
  id            String   @id @default(uuid())
  telegramId    BigInt   @unique @map("telegram_id")
  chatId        BigInt   @map("chat_id")
  username      String?
  firstName     String?  @map("first_name")

  // Subscriptions (multiple allowed, only one active at a time)
  subscriptions SearchSubscription[]

  // Conversation state for multi-step setup
  conversationState  String?  @map("conversation_state")
  conversationData   Json?    @map("conversation_data")

  // If true, skip jobs already matched via other subscriptions
  // If false, show them with a marker
  skipCrossSubDuplicates  Boolean  @default(true) @map("skip_cross_sub_duplicates")

  createdAt     DateTime @default(now()) @map("created_at")
  lastActiveAt  DateTime @default(now()) @map("last_active_at")

  @@map("telegram_users")
}

// User's job search subscription (multiple allowed, only one active at a time)
model SearchSubscription {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  user            TelegramUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Search parameters
  jobTitles       String[] @map("job_titles")
  location        String?                               // DEPRECATED: use normalizedLocations
  isRemote        Boolean  @default(true) @map("is_remote")  // DEPRECATED: use normalizedLocations
  normalizedLocations  Json?  @map("normalized_locations")   // NormalizedLocation[] - structured location data
  jobTypes        String[] @default([]) @map("job_types")    // fulltime, parttime, internship, contract (empty = all)
  minScore        Int      @default(60) @map("min_score")
  datePosted      String   @default("month") @map("date_posted") // today, 3days, week, month, all
  resumeText      String   @map("resume_text")
  resumeHash      String   @map("resume_hash")
  resumeName      String?  @map("resume_name")
  resumeUploadedAt DateTime @default(now()) @map("resume_uploaded_at")

  // Exclusion filters
  excludedTitles    String[] @default([]) @map("excluded_titles")
  excludedCompanies String[] @default([]) @map("excluded_companies")

  // Status
  isActive        Boolean  @default(true) @map("is_active")
  isPaused        Boolean  @default(false) @map("is_paused")
  debugMode       Boolean  @default(false) @map("debug_mode") // Enable detailed logging for debugging

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  lastSearchAt    DateTime? @map("last_search_at")
  nextRunAt       DateTime? @map("next_run_at") // When to run next (null = run immediately)

  // Track sent notifications
  sentNotifications SentNotification[]

  // Observability relations
  runs        SubscriptionRun[]
  skillStats  SkillStats[]

  @@map("search_subscriptions")
}

// Track which job matches have been sent to avoid duplicates
model SentNotification {
  id              String   @id @default(uuid())
  subscriptionId  String   @map("subscription_id")
  subscription    SearchSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  jobMatchId      String   @map("job_match_id")
  jobMatch        JobMatch @relation(fields: [jobMatchId], references: [id], onDelete: Cascade)
  sentAt          DateTime @default(now()) @map("sent_at")

  @@unique([subscriptionId, jobMatchId])
  @@map("sent_notifications")
}

// Persistent download tokens for CSV exports (survives server restarts)
model DownloadToken {
  id        String   @id @default(uuid())
  token     String   @unique
  filename  String
  content   String?  // CSV content stored in database for persistence
  createdAt DateTime @default(now()) @map("created_at")

  @@map("download_tokens")
}

// ============================================================
// OBSERVABILITY MODELS
// ============================================================

// Track each subscription execution (scheduled or manual)
model SubscriptionRun {
  id              String   @id @default(uuid())
  subscriptionId  String   @map("subscription_id")
  subscription    SearchSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  triggerType     String   @map("trigger_type")  // "scheduled" | "manual"
  status          String   // "running" | "completed" | "failed"

  startedAt       DateTime @default(now()) @map("started_at")
  completedAt     DateTime? @map("completed_at")
  durationMs      Int?     @map("duration_ms")

  // Metrics
  jobsCollected     Int    @default(0) @map("jobs_collected")
  jobsAfterDedup    Int    @default(0) @map("jobs_after_dedup")
  jobsMatched       Int    @default(0) @map("jobs_matched")
  notificationsSent Int    @default(0) @map("notifications_sent")

  // Error tracking
  errorMessage    String?  @map("error_message")
  errorStack      String?  @map("error_stack")
  failedStage     String?  @map("failed_stage")  // "collection" | "normalization" | "matching" | "notification"
  errorContext    Json?    @map("error_context") // Structured debug info: {query, location, partialResults, etc.}

  @@index([subscriptionId, startedAt])
  @@index([status])
  @@index([startedAt])
  @@map("subscription_runs")
}

// Aggregate skill data for insights (updated per search)
model SkillStats {
  id              String   @id @default(uuid())
  subscriptionId  String   @map("subscription_id")
  subscription    SearchSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  skill           String
  matchedCount    Int      @default(0) @map("matched_count")   // Times this skill matched
  missingCount    Int      @default(0) @map("missing_count")   // Times this skill was missing
  demandCount     Int      @default(0) @map("demand_count")    // Times seen in job requirements

  updatedAt       DateTime @updatedAt @map("updated_at")

  @@unique([subscriptionId, skill])
  @@index([subscriptionId])
  @@map("skill_stats")
}

// Market data snapshots (aggregated daily)
model MarketSnapshot {
  id              String   @id @default(uuid())
  date            DateTime @default(now())

  // Query context
  jobTitles       String[] @map("job_titles")
  location        String?
  isRemote        Boolean  @map("is_remote")

  // Aggregated data
  totalJobs       Int      @map("total_jobs")
  avgSalaryMin    Int?     @map("avg_salary_min")
  avgSalaryMax    Int?     @map("avg_salary_max")
  remoteCount     Int      @map("remote_count")
  topCompanies    Json     @map("top_companies")    // [{company, count}]
  topSkills       Json     @map("top_skills")       // [{skill, count}]
  topLocations    Json     @map("top_locations")    // [{location, count}]

  @@index([date])
  @@map("market_snapshots")
}
